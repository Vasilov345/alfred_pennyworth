Decorators:

1. Під мостом завівся Троль, який систематично і бездушно забирає плату за прохід мостом
Оскільки ми проти расизму, то допоможемо Тролю правильно забирати кошти в людей.
Створіть декоратор Troll, та застосуйте його до функції bridge, по якій ходять люди Person. 
За прохід по мосту в них віднімаються кошти, якщо їх достатньо. 
Якщо ні, то TrollIsAngry exception не дасть людині перейти міст!

2. Створіть декоратор (Timer), який засікає час роботу функції. Для створення декоратора використайте class, а не function.


# adding a decorator to the function 
```
@Timer
def some_function(delay): 
    from time import sleep 

    # Introducing some time delay to  
    # simulate a time taking function. 
    sleep(delay) 

some_function(3)
```
3. recursion + factorial
Нашіть функцію, яка рекурсивно рахує факторіал, а заодно декоратор, який перевіряє чи вхідне значення ціле та позитивне число:
```
def argument_test_natural_number(f):
    # check is arg to f is int and > 0, raise error otherwise
```


4. Напишіть программу, яка виводить частину послідовності 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 .... 
 На вхід приймається значення n - кількість елементів послідовності, які мають бути виведенні 

Наприклад, якщо n = 7, то программа має вивести 1 2 2 3 3 3 4.
Sample Input:
7
Sample Output:
1 2 2 3 3 3 4


5. Напишіть програму, яка зчитує з консолі числа (по одному в строці) до тих пір,
пока сума сум введених чисел не буде рівною 0 і, відповідно, після цього виводить сумму квадратів усіх введених чисел.
У прикладі ми зчитуємо числа 1, -3, 5, -6, -10, 13; в цей момент помічаємо, що сума цих чисел рівна 0.
і виводим сумму їх квадратів зупиняючи зчитування з консолі.
Sample Input:
1
-3
5
-6
-10
13
4
-8
Sample Output:
340

5. Одне із застосувань множинного успадкування - розширення функціональності класу якимось заздалегідь визначеним способом.
Наприклад, якщо нам знадобиться залогувати якусь інформацію при зверненні до методів класу.
Розглянемо класс Loggable:
```
import time
class Loggable:
    def log(self, msg):
        print(str(time.ctime()) + ": " + str(msg))
```

У нього є рівно один метод log, який дозволяє виводити в лог (в даному випадку в stdout) якесь повідомлення,
додаючи при цьому поточний час.
Реалізуйте клас LoggableList, унаслідував його від класів list і Loggable таким чином,
щоб при додаванні елемента в список за допомогою методу append в лог відправлялося повідомлення, що складається з тількищо доданого елемента.


6. Реалізуйте клас PositiveList, унаслідував його від класу list, для зберігання позитивних цілих чисел.
Також реалізуйте нове виключення NonPositiveError.
У класі PositiveList перевизначите метод append (self, x) таким чином, щоб при спробі додати
 непозитивним ціле число викликалося виключення  NonPositiveError і число не додавалося,
 а при спробі додати позитивне ціле число, число додавалося б як в стандартний list.
